optimal_model <- optimal(sfpca_stan_results)
summary(optimal_model)
```
plot_k_diagnostic(dat, optimal_model)
data("ECAM")
head(ECAM)
sfpca_data=dat
model=optimal_model
N <- sfpca_data$num_subjects
loo_best <- model$looic
pkdf <- data.frame(pk = loo_best$diagnostics$pareto_k, id = 1:N)
sfpca_stan_results <- stan_fit(data = dat, Nsamples = 1000, Nchain = 3,
PC_max = 3, D_max = 3)
sfpca_stan_results <- stan_fit(data = dat, Nsamples = 1000, Nchain = 3,
PC_max = 3, D_max = 3)
save(sfpca_stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
View(ECAM)
n=10000
x=rnorm(n)
z=rnorm(n)
y=2*x+z+rnorm(n)
fit=lm(y~x+z)
print(coef(fit)[['x']])
with(biostat615, welcome(students))
data=ECAM
unique_subject_id = 'studyid'
time_name = 'month_of_life'
response_name = 'shannon'
transform_y = 'standardize'
scale_time = T
if (!(unique_subject_id %in% colnames(data)) |
!(time_name %in% colnames(data)) |
!(response_name %in% colnames(data))) stop("Variable name is not in data")
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name))]
View(data_check)
data_check[duplicated(data_check), ]
duplicated(data_check)
data_duplicate <- data_check[duplicated(data_check), ]
View(data_duplicate)
keys <- colnames(data)[!grepl('shannon',colnames(data))]
X <- as.data.frame(data)
X[,list(mm= mean(shannon)),keys]
X <- as.data.table(data)
data_duplicate <- data_check[duplicated(data_check) | duplicated(data_check, fromLast = T), ]
View(data_duplicate)
data_duplicate <- data_check[duplicated(data_check), ]
View(data_duplicate)
a <- aggregate(shannon,by=list(name=unique_subject_id,etc1=time),data=data,FUN=mean)
a <- aggregate(response_name,by=list(name=unique_subject_id,etc1=time),data=data,FUN=mean)
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), response_name)]
a <- aggregate(response_name,by=list(name=unique_subject_id,etc1=time),data=data_check,FUN=mean)
a <- aggregate(response_name,by=list(unique_subject_id=unique_subject_id,etime=time_name),data=data_check,FUN=mean)
View(a)
View(data_check)
a <- aggregate(response_name,by=list(unique_subject_id=unique_subject_id,time=time_name),data=data_check,FUN=mean)
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), as.numeric(response_name))]
response_name
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), as.numeric(response_name))]
data=ECAM
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), as.numeric(response_name))]
unique_subject_id
time_name
response_name
View(data)
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), as.character(response_name))]
data_check[, response_name] <- as.numeric(data_check[, response_name])
a <- aggregate(response_name,by=list(unique_subject_id=unique_subject_id,time=time_name),data=data_check,FUN=mean)
View(a)
lapply(data_check,class)
a <- aggregate(response_name,data=data_check,FUN=mean)
a <- aggregate(response_name,by=list(unique_subject_id=unique_subject_id),data=data_check,FUN=mean)
View(a)
a <- aggregate(data_check[,response_name],by=list(unique_subject_id=unique_subject_id,time=time_name),data=data_check,FUN=mean)
data_check[,response_name]
a <- aggregate(data_check[,response_name],by=list(unique_subject_id=data_check[,unique_subject_id],
time=data_check[,time_name]),data=data_check,FUN=mean)
View(a)
4.1435515+4.1175688
8.26112/2
duplicated(data_check)
data_unique <- data[!duplicated(data[, c(unique_subject_id, time_name)]), ]
devtools::load_all(".")
devtools::load_all(".")
library(BayesTime)
data("ECAM")
data = ECAM
unique_subject_id = 'studyid'
time_name = 'month_of_life'
response_name = 'shannon'
data_unique <- data[!duplicated(data[, c(unique_subject_id, time_name)])]
unique_subject_id
time_name
data[, c(unique_subject_id, time_name)
]
data_unique <- data[!duplicated(data[, c(unique_subject_id, time_name)]), ]
View(data_unique)
data_duplicate <- data_check[duplicated(data_check) | duplicated(data_check, fromLast = T), ]
# check if each subject has unique measurement at each time point
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name), as.character(response_name))]
#data_duplicate <- data_check[duplicated(data_check), ]
data_duplicate <- data_check[duplicated(data_check) | duplicated(data_check, fromLast = T), ]
#data_duplicate <- data_check[duplicated(data_check), ]
data_duplicate <- data_check[duplicated(data_check) | duplicated(data_check, fromLast = T), ]
#data_duplicate <- data_check[duplicated(data_check), ]
data_duplicate <- data_check[duplicated(data_check[-3]) | duplicated(data_check[-3], fromLast = T), ]
View(data_duplicate)
View(data_check)
install.packages('data.table')
install.packages("data.table")
install.packages("data.table")
install.packages("data.table")
install.packages("data.table")
install.packages("data.table")
library(data.table)
keys <- colnames(dat)[!grepl('shannon',colnames(data))]
keys <- colnames(data)[!grepl('shannon',colnames(data))]
X <- as.data.table(data)
X[,list(mm= mean(shannon)),keys]
unqie <- X[,list(mm= mean(shannon)),keys]
View(unqie)
keys <- colnames(data)[!grepl('shannon',colnames(data))][-1]
X <- as.data.table(data)
unqie <- X[,list(mm= mean(shannon)),keys]
View(unqie)
dupli_ids <- data_check[, unique_subject_id]
dupli_ids <- unique(data_check[, unique_subject_id])
stop(paste('Subject', dupli_ids,
'have duplicate measurements at the same timepoint.'))
paste('Subject', dupli_ids,
'have duplicate measurements at the same timepoint.')
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name))]
devtools::load_all(".")
devtools::load_all(".")
library(BayesTime)
data("ECAM")
data = ECAM
unique_subject_id = 'studyid'
time_name = 'month_of_life'
response_name = 'shannon'
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name))]
if (sum(duplicated(data_check)) != 0) {
dupli_ids <- unique(data_check[, unique_subject_id])
dupli_times <- unique(data_check[, time_name])
stop(paste('Subject', dupli_ids, 'at timepoint', dupli_times,
'has duplicate measurements.'))
}
stop(paste('Subject', dupli_ids, 'has duplicate measurements.'))
stop(paste('Subject', paste(dupli_ids, sep = ','), 'has duplicate measurements.'))
if (sum(duplicated(data_check)) != 0) {
dupli_ids <- unique(data_check[, unique_subject_id])
stop(paste('Subject', paste(dupli_ids, sep = ','), 'has duplicate measurements.'))
}
paste(dupli_ids, sep = ',')
paste('Subject', paste(dupli_ids, sep = ','), 'has duplicate measurements.')
stop(paste('Subject', paste(dupli_ids, sep = ','), 'has duplicate measurements.', by= ' '))
paste(dupli_ids, sep = ',')
stop(paste('Subject', paste(dupli_ids, sep = ',', collapse = ''), 'has duplicate measurements.', by= ' '))
paste(dupli_ids, sep = ',', collapse = '')
stop(paste('Subject', paste(dupli_ids, sep = ',', collapse = ','), 'has duplicate measurements.', by= ' '))
data('BayesTime/data/ECAM.rda')
setwd("~/Dropbox/lab")
data('BayesTime/data/ECAM.rda')
setwd("~/Dropbox/lab/SFPCA")
data('BayesTime/data/ECAM.rda')
data('BayesTime/data/ECAM')
load(file = 'BayesTime/data/ECAM')
gwd
gwp
getwd()
load(file = 'BayesTime/data/ECAM.rda')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
library(data.table)
source('stan_revised.R')
source('BayesTime/stan_revised.R')
source(file = 'BayesTime/stan_revised.R')
source(file = 'BayesTime/sfpca_revised.R')
source(file = 'sfpca_revised.R')
Nsamples = 1000
Nchains = 3
model_file = "stan_speed_r/sfpca.stan"
smod = stan_model(model_file)
PC_max = 1 # number of PCs
D_max = 1 # number of knots
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 1, smod, prepared_data)
end_time <- Sys.time()
before <- end_time - start_time
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 1, smod, dat)
end_time <- Sys.time()
before <- end_time - start_time
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
source(file = 'BayesTime/R/prepare_data.R')
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
# check if each subject has unique measurement at each time point
if (duplicate == FALSE){
data_check <- data[, c(as.character(unique_subject_id), as.character(time_name))]
if (sum(duplicated(data_check)) != 0) {
dupli_ids <- unique(data_check[, unique_subject_id])
stop(paste('Subject', paste(dupli_ids, sep = ',', collapse = ','), 'has duplicate measurements.', by= ' '))
}
# } else if (duplicate == TRUE & is.null(keys)) {
#   stop('')
}
source(file = 'BayesTime/R/prepare_data.R')
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
source(file = 'BayesTime/R/prepare_data.R')
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 1, smod, dat)
end_time <- Sys.time()
before <- end_time - start_time
View(sfpca_stan)
#test after changing the line of Y~noraml
model_file_revised = "stan_speed_r/sfpca_revised.stan"
smod_revised = stan_model(model_file_revised)
before <- end_time - start_time
before
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 1, smod_revised, dat)
end_time <- Sys.time()
after<- end_time - start_time
after
before
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 3, smod, dat)
end_time <- Sys.time()
before <- end_time - start_time
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 3, smod_revised, dat)
end_time <- Sys.time()
after<- end_time - start_time
before
after
meta <- read.delim('../Kids/Qiime2/data/11405_prep_3914_qiime_20190424-152313.txt', sep="\t", stringsAsFactors = F)
meta_young <- meta[meta$age_group == 'young', ]
shannon <-read.csv('..Kids/Qiime2/data/60671-alpha_shannon/alpha-diversity.tsv', stringsAsFactors=FALSE, sep='\t')
shannon <-read.csv('../Kids/Qiime2/data/60671-alpha_shannon/alpha-diversity.tsv', stringsAsFactors=FALSE, sep='\t')
data <- merge(meta_young, shannon, by.x = 'X.SampleID', by.y = 'X')
data = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_var='age',
response='shannon', transform.y='standardize', scale.time=TRUE)
source(file = 'BayesTime/R/prepare_data.R')
data = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_var='age',
response='shannon', transform.y='standardize', scale.time=TRUE)
data = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_name='age',
response_name='shannon', transform_y='standardize', scale_time=TRUE)
dat = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_name='age',
response_name='shannon', transform_y='standardize', scale_time=TRUE)
data <- merge(meta_young, shannon, by.x = 'X.SampleID', by.y = 'X')
dat = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_name='age',
response_name='shannon', transform_y='standardize', scale_time=TRUE)
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 3, smod, dat)
end_time <- Sys.time()
before <- end_time - start_time
before
start_time <- Sys.time()
sfpca_stan(PC_max, D_max, Nsamples = 1000, Nchain = 3, smod_revised, dat)
end_time <- Sys.time()
after<- end_time - start_time
after
library(processx)
sessionInfo()
library(devtools)
install_github('y1zhong/bayestime')
library(BayesTime)
data("ECAM")
head(ECAM)
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
sfpca_stan_results <- stan_fit(data = dat, Nsamples = 1000, Nchain = 3,
PC_max = 1, D_max = 1)
library(BayesTime)
data("ECAM")
data = ECAM
response <- data[, response_name]
car::qqPlot(response, main = '1')
car::qqPlot(response, main = 'Response')
car::qqPlot(log(response), main = 'Log Transformation of Response')
car::qqPlot(log(response), main = 'Log Trans of Response')
car::qqPlot(sqrt(response), main = 'Square Root of Response')
car::qqPlot(response, main = 'Response', ylab = 'value')
#qubic root
car::qqPlot(response ^ (1/3), main = 'Qubic Root of Response', ylab = 'value')
par(mfrow=c(2,2))
response <- data[, response_name]
car::qqPlot(response, main = 'Response', ylab = 'value')
car::qqPlot(log(response), main = 'Log Trans of Response', ylab = 'value')
car::qqPlot(sqrt(response), main = 'Square Root of Response', ylab = 'value')
#qubic root
car::qqPlot(response ^ (1/3), main = 'Qubic Root of Response', ylab = 'value')
car::qqPlot(response, main = 'Response', ylab = 'value')
car::qqPlot(log(response), main = 'Log Transformation', ylab = 'value')
car::qqPlot(sqrt(response), main = 'Square Root', ylab = 'value')
#qubic root
car::qqPlot(response ^ (1/3), main = 'Qubic Root', ylab = 'value')
par(mfrow=c(1,1))
car::qqPlot(log(response), main = 'Log Transform', ylab = 'value')
devtools::load_all(".")
devtools::load_all(".")
library(BayesTime)
library(BayesTime)
plot_qqplot(data = ECAM, 'shannon')
plot_qqplot(ECAM, 'shannon')
if (!response_name %in% colnames(data)) {
stop("Input response name not in data")
}
par(mfrow=c(2,2))
response <- data[, response_name]
car::qqPlot(response, main = 'Response', ylab = 'response')
car::qqPlot(log(response), main = 'Log Transform', ylab = 'response')
car::qqPlot(sqrt(response), main = 'Square Root', ylab = 'response')
car::qqPlot(response ^ (1/3), main = 'Qubic Root', ylab = 'response')
par(mfrow=c(1,1))
plot_qqplot(ECAM, 'shannon')
View(plot_qqplot)
library(BayesTime)
library(devtools)
install_github('y1zhong/bayestime)
install_github('y1zhong/bayestime')
install_github('y1zhong/bayestime')
install_github('y1zhong/bayestime')
install_github('y1zhong/bayestime')
library(BayesTime)
data("ECAM")
head(ECAM)
plot_qqplot(ECAM, 'shannon')
colnames(ECAM)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
plot_qqplot(ECAM, response)
unique_subject_id = unique_subject_id, group_name = 'delivery)
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, group_name = 'delivery')
library(BayesTime)
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
library(BayesTime)
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all(.)
devtools::load_all('.')
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
data("ECAM")
head(ECAM)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all('.')
library(BayesTime)
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data |= ECAM, time_name = time, response_name = response,
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
variable_name
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
devtools::load_all("BayesTime")
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
#sfpca_stan_results <- stan_fit(data = dat, Nsamples = 1000, Nchain = 3,
#                         PC_max = 3, D_max = 3)
#save(sfpca_stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
load('~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
optimal_model <- optimal(model_list = sfpca_stan_results)
model_list = sfpca_stan_results
len <- length(model_list)
looic.list <- lapply(1:len, function(i) model_list[[i]]$looic)
looic.obj <- loo::loo_compare(looic.list)
print(looic.obj)
class(looic.obj)
View(model_list)
looic.obj.df <- as.data.frame(looic.obj)
View(looic.obj.df)
looic.obj.df <- as.data.frame(looic.obj)[, c(1:2)]
looic.obj.df <- as.data.frame(looic.obj)[, c(1, 2)]
looic.obj.df <- as.data.frame(looic.obj)[, c('elpd_diff', 'se_diff')]
model.name <- rownames(looic.obj)
model.index <- as.numeric(gsub(".*?([0-9]+).*", "\\1", model.name))
View(looic.list)
pc <- model.list[[model.index]]$pc
pc <- model_list[[model.index]]$pc
pc <- model_list[[model.index]]
pc <- lapply(model.index, function(x)model_list[[x]]$pc)
View(pc)
print(looic.obj.df)
devtools::load_all("BayesTime")
optimal_model <- optimal(model_list = sfpca_stan_results)
pc <- unlist(lapply(model.index, function(x) model_list[[x]]$pc))
knot <- unlist(lapply(model.index, function(x) model_list[[x]]$knot))
devtools::load_all("BayesTime")
optimal_model <- optimal(model_list = sfpca_stan_results)
devtools::load_all("BayesTime")
optimal_model <- optimal(model_list = sfpca_stan_results)
devtools::load_all("BayesTime")
optimal_model <- optimal(model_list = sfpca_stan_results)
summary(optimal_model)
optimal.name <- rownames(looic.obj)[1]
optimal.index <- as.numeric(gsub(".*?([0-9]+).*", "\\1", optimal.name))
optimal.index
model_list[[optimal.index]]
summary(optimal_model)
optimal_model <- optimal(model_list = sfpca_stan_results)
summary(optimal_model)
len <- length(model_list)
looic.list <- lapply(1:len, function(i) model_list[[i]]$looic)
looic.obj <- loo::loo_compare(looic.list)
looic.obj.df <- as.data.frame(looic.obj)[, c('elpd_diff', 'se_diff')]
model.name <- rownames(looic.obj)
model.index <- as.numeric(gsub(".*?([0-9]+).*", "\\1", model.name))
pc <- unlist(lapply(model.index, function(x) model_list[[x]]$pc))
knot <- unlist(lapply(model.index, function(x) model_list[[x]]$knot))
looic.obj.df$pc <- pc
looic.obj.df$knot <- knot
print(looic.obj.df)
optimal.name <- rownames(looic.obj)[1]
optimal.index <- as.numeric(gsub(".*?([0-9]+).*", "\\1", optimal.name))
summary(model_list[[optimal.index]])
optimal.index
summary(model_list[[7]])
View(model_list)
summary(model_list[[2]])
summary(model_list[[9]])
summary(model_list[[10]])
summary(model_list[[2]])
summary(model_list)
model_list = sfpca_stan_results
View(model_list)
N <- data$num_subjects
data = dat
N <- data$num_subjects
loo_best <- model$looic
pkdf <- data.frame(pk = loo_best$diagnostics$pareto_k, id = 1:N)
model = optimal_model
loo_best <- model$looic
pkdf <- data.frame(pk = loo_best$diagnostics$pareto_k, id = 1:N)
View(pkdf)
bad <- pkdf[pkdf$pk > 0.7, ]
View(bad)
devtools::load_all("BayesTime")
plot_k_diagnostic(data = dat, model = optimal_model)
devtools::load_all("BayesTime")
plot_k_diagnostic(data = dat, model = optimal_model)
plot_posterior_diagnostic(data = dat, model = optimal_model)
model_basis <- basis_setup_sparse(dat, nknots = optimal_model$knot, orth=TRUE)
View(dat)
View(data)
colnames(data$data) %in% c('ID', 'time', 'response')
colnames(data$data)[!colnames(data$data %in% var_require)]
var_require <- c('ID', 'time', 'response')
c(var_require, colnames(data$data)[!colnames(data$data %in% var_require)])
vars_complete <- c(var_require, colnames(data$data)[!colnames(data$data) %in% var_require])
!colnames(data$data) %in% var_require
colnames(data$data)[!colnames(data$data) %in% var_require]
vars_complete <- c(var_require, colnames(data$data)[!colnames(data$data) %in% var_require])
devtools::load_all("BayesTime")
model_output <- output_results(data = dat, model = optimal_model)
View(model_output)
lapply(model_output$df, class)
summary(model_output)
#print out the memory use for different data structure
vec_size = 1024L
numeric_vec = rep(1.0,length=vec_size)
integer_vec = rep(1L,length=vec_size)
logical_vec = rep(TRUE,length=vec_size)
character_vec = rep("a",length=vec_size)
A_list = as.list(numeric_vec)
cat("R memory allocated for a numeric vector of length", vec_size, "is", object.size(numeric_vec),"bytes. \n")
cat("R memory allocated for an integer vector of length", vec_size, "is", object.size(integer_vec),"bytes. \n")
cat("R memory allocated for a logical vector of length", vec_size, "is", object.size(logical_vec),"bytes. \n")
cat("R memory allocated for a character vector of length", vec_size, "is", object.size(character_vec),"bytes. \n")
cat("R memory allocated for a list with", length(A_list), "elements is", object.size(A_list),"bytes. \n")
